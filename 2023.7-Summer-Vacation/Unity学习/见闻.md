枕头里藏着发霉的梦，梦里住着无法拥有的人

#### 见闻

经验 > 学历

选择 > 努力

大组 > 小组

争取进入大组，大组导师资源丰富。

先小厂，后大厂

#### Code Runner ：scriptcs运行C#

scriptcs用于简单的运行C#，而不需要安装VS（每个文件都是一个超大的项目）。

步骤：

1. 管理员身份运行CMD

2. 输入
   ```powershell
   @powershell -NoProfile -ExecutionPolicy Unrestricted -Command "iex ((New-Object Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))" && SET PATH=%PATH%;%systemdrive%\chocolatey\bin
   ```

   这是用来安装win下的包管理器chocolatey

3. 继续输入
   ```powershell
   choco install chocolatey-compatibility.extension
   ```

   这不太清楚有什么作用，但是是需要的。

4. 安装能够直接运行cs文件的执行器scriptcs

   ```
   choco install scriptcs
   ```

   遇到提示就输入y

5. 接下来就可以用coderunner运行c#了

#### 缺点：

貌似没法运行tuple

#### 序列化与反序列化

序列化：将对象转化为可传输字节序列的过程

反序列化：将可传输字节序列转化为对象

序列化目的：对象跨平台存储，和进行网络传输。网络传输方式就是IO，IO支持的数据格式就是字节数组。

单方面的只把对象转成字节数组还不行，因为没有规则的字节数组我们是没办法把对象的本来面目还原回来的，所以我们必须在把对象转成字节数组的时候就制定一种规则**（序列化）**，那么我们从IO流里面读出数据的时候再以这种规则把对象还原回来**（反序列化）。**

# Unity

#### 制作碰撞效果

1. RigidBody2D脚本设置成刚体
2. Collider 2D设置碰撞体积
3. 一个触发OnCollide效果的脚本

如果isTrigger为真，那么会触发碰撞脚本，但是没有物理效果。



#### 坐标

Hierarchy中处在根目录下的元素transform坐标是相对于世界的(0,0,0)

H处在父元素下的元素transform坐标是相对于父亲的。

如果遇到需要整理对象（元素放到某个空对象下）并仍希望子元素相对世界，可以将空的父元素坐标设置为(0,0,0)



## 编写游戏代码

#### 第一次认知

```c#
// 声明一个叫做SpawnerSample脚本（实际上是个类），继承自MonoBehavior，可被Unity识别为脚本
public class SpawnerSample : MonoBehaviour
{
    // 声明一个GameObject属性，public使得其可以被Inspector发现并且由开发者赋值
    public GameObject ObjectToSpawn;

    // Start生命周期，在游戏初始化时执行，只会被执行一次
    void Start()
    {
        int angle = 15;
        // 下面的transoform.position是省略语
        // 实际上是脚本挂载对象即gameObject的position
        // 这个position指的是inspector里Transofrm组件显示的位置，它是相对于·父亲·的。
        Vector3 spawnPosition = transform.position;

        
        // Quaternion是Unity的四元数类，用于旋转相关
        //Euler是一个静态方法，
		// 返回一个旋转，它围绕 z 轴旋转 z 度、围绕 x 轴旋转 x 度、围绕 y 轴旋转 y 度（按该顺序应用）。
        // Verctor3.right就是x轴单位向量，x轴为旋转边，旋转angle度
        // 估计表面上使用了欧拉角，实际上内部计算用的是四元数
        Vector3 direction = Quaternion.Euler(0, angle, 0) * Vector3.right;
        // 修改spawnPosition，加上了direction的2倍，也就是距离原点2单位。
        spawnPosition = transform.position + direction * 2;
        // Instantiate类似编辑器中复制命令创建一个ObjectToSpawn的副本，默认父对象为NULL
		// 在这里使用的重载中，第二个参数指定生成位置，第三个参数指定旋转方向，identity是不旋转
        Instantiate(ObjectToSpawn, spawnPosition, Quaternion.identity);

        angle = 55;
        direction = Quaternion.Euler(0, angle, 0) * Vector3.right;
        spawnPosition = transform.position + direction * 2;
        Instantiate(ObjectToSpawn, spawnPosition, Quaternion.identity);

        angle = 95;
        direction = Quaternion.Euler(0, angle, 0) * Vector3.right;
        spawnPosition = transform.position + direction * 2;
        Instantiate(ObjectToSpawn, spawnPosition, Quaternion.identity);
    }
}
```

#### Instantiate的问题

使用Instantiate创建物品对象，不会调用Start，而是会调用Awake。

所以物品对象最好在Awake中获取某些组件，例如r2d。

#### Awake

在场景初始化时，脚本包含活动GameObject或者Sleep的GameObject变为活动时，或者Object.Instantiate创建GameObject时，都将调用Awake，可以在Awake里初始化变量【Unity推荐使用Awake代替构造函数】。脚本实例的生命周期内，只调用Awake一次。

#### 用键盘操作人物移动

```c#
void Update()
{
    // 接受水平方向输入
    float horizontal = Input.GetAxis("Horizontal");
    // 垂直方向
    float vertical= Input.GetAxis("Vertical");
    transform.Translate(speed * horizontal, speed * vertical, 0f);
}
```

接受输入用的是InputManager，一个Unity自带的输入类（这是老版本的输入类，现在Unity推荐使用新输入类Inpute System，需要手动import，老版的input manager默认自带）

菜单栏中Edit->Project Settings->Input Manager中可以看到该输入类的详细信息。

<img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20230709154630886.png" alt="image-20230709154630886" style="zoom: 67%;" />

默认Horizontal输入设备是Key or Mouse Button，并且a为负(产生-1)，d为正(产生+1)。

Unity的输入本身自带平滑效果，会从0渐变到1或-1，因此松开案件后物体依旧会移动。

#### 移动距离与时间挂钩而非帧数挂钩

可以固定帧数

```c#
void Start(){
    // 关闭垂直同步，于是可以手动设定帧数；否则可以选择固定30或60帧
	QualitySettings.vSyncCount = 0;
    // 固定帧数为10帧。
	Application.targetFrameRate = 10;
}
```

或者改为直接与时间挂钩

```c#
```



#### 类属性有个子类，希望该子类也能在Inspector中设置

为该类添上[Serializable] Attribute。

```c#
public class MainPlayer : MonoBehaviour
{

    public Cat cat;
    void Start()
    {
        this.cat.Print();
    }

}

// 在此处添上注解
[Serializable]
public class Cat {
    public string catName;
    public int age;
    public Cat(string catName, int age)
    {
        this.catName = catName;
        this.age = age;
    }
    public void Print()
    {
        Debug.Log($"Cat Name:{this.catName},Cat Age:{this.age}");
    }
};
```

#### 2D创建瓦片

2022.3.1 英文版操作步骤：

1.  把图片拖入Project （texture type应该自动为sprite 2D UI）
2.  菜单栏中windows -> 2d -> tile palette,弹出面板 
3.  面板左侧偏上位置Create New Palette，输入名字，拖入之前的图片，就创建完成了

#### 2D瓦片未铺满

1. 查看原sprite的inspector，找到pixels per unit
   ![image-20230711125156236](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20230711125156236.png)

2. 点击inspector中Sprite Editor查看原图片大小，发现只有64pixel

   ![image-20230711125316439](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20230711125316439.png)

3. 因此修改原来的Pixels Per Unit为64即可

#### 删除2D瓦片

1. 选中瓦片（无论是在scene里还是在tile palette里）

2. 在inspector里找到Delete Selection，点击后删除。

   ![image-20230711133259675](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20230711133259675.png)

#### 同时导入多个Sprite进Tile Palette

一般来说为了节省效率和空间，往往会将多张图片（也就是瓦片）合并在一张图片之中（精灵图嘛），它里面包含了多个瓦片，我们需要将其分割，并一起导入到palette中。所以需要告诉unity如何分割这张精灵图。

1. 设置Sprite Mode 和 Pixels Per Unit。
   ![image-20230711133656372](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20230711133656372.png)
   前者改为Multiple，后者在Sprite Editor中改为跟WH相匹配。（W64,H64，则PPU = 64；PPU表示一个单位长度对应多少像素。)
2. 在Sprite Editor最上方找到Slice，修改Type为Grid By Cell Count；Col & Row改为相应的分割成的小瓦片的行列数。最后点击Slice完成。记得Apply保存。
   ![image-20230711134343006](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20230711134343006.png)

#### 绘画层叠问题

保证先画地图，后画角色。

1. Hierarchy中选择Tilemap对象，找到TIlemap Renderer组件 -> Additional Settings -> Order in Layer.
2. Order in Layer决定了Unity绘制同一图层中绘制物体顺序，越小越先绘画，随意将Tilemap的order设置为-10，人物的order设置为0就可以了。

注意此方法解决的是“排序恒等”的情况，即永远都是地图在下人物在上，如果对于一个箱子之类的来说，有时人物在前，有时箱子在前，那么这个方法就不适用了。

#### 创建Prefab

1. 在Assets下创建Prefabs文件夹
2. 将Sprite拖入Hierarchy，产生一个Object，再将Object拖入Prefabs文件夹。

双击一个Prefab可以进行编辑。

#### 去掉某些物理效果

Rigid 2d可能会产生一些你并不想要的物理效果。

![image-20230711154815909](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20230711154815909.png)

此时如果继续让人物向右移动，会导致人物逆时针旋转。

在Rigid 2D 组件中冻结旋转。

![image-20230711154859852](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20230711154859852.png)

#### 人物抖动问题

持续按住方向键，人物会在箱子附近抖动。

#### ![image-20230711160121065](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20230711160121065.png)

#### 解决人物抖动

生命周期Update()：每一帧时被调用，在不同电脑上帧刷新时间不同。

生命周期FixedUpdate()：调用间隔时间固定，默认为0.02s，可以通过Time.fixedDeltaTime来访问该值。

可以在project settings中修改。

![image-20230711161506428](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20230711161506428.png)

修改代码如下。

首先我们需要手动获取rigid2d组件（在Start中），之前不用获取transform是因为所有对象都有transform

其次我们需要在Update中获取用户输入，在FixedUpdate中计算物理效果（移动刚体本身而不是transform），物理系统会将游戏对象同步到刚体位置。

这样的话，我们现在物理场景中计算好了能不能位移，再去移动物体；而不是先移动物体，再在物理场景中计算，发生碰撞把物体挪回来。

```c#
public class RubyController : MonoBehaviour
{
    // Start is called before the first frame update
    public float speed;
    Rigidbody2D r2d;
    private  float horizontal = 0;
    private  float vertical = 0;

    void Start()
    {
        Debug.Log($"Time.fixedDeltaTime:{ Time.fixedDeltaTime }");
        Debug.Log($"Time.deltaTime:{ Time.deltaTime }");
        r2d = GetComponent<Rigidbody2D>();

    }

    // Update is called once per frame
    void Update()
    {
         horizontal = Input.GetAxis("Horizontal");
         vertical= Input.GetAxis("Vertical");
    }
    void FixedUpdate()
    {
        Vector2 p = r2d.position;
        p.x += speed * horizontal * Time.deltaTime;
        p.y += speed * vertical * Time.deltaTime;

        r2d.MovePosition(p);
    }
}
```

#### fixedDeltaTime和deltaTime的区别

fixed是始终固定的，无论在何处调用，都是同一个值（默认是0.02）；

但对于deltaTime来说

如果Update中获取，那么它的时间间隔将会发生改变，非常不稳定，所以不适合物理计算，因为万一间隔过大错过了就产生了问题。

![image-20230711173127729](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20230711173127729.png)

如果deltaTime放在FixedUpdate中，就被固定了。

![image-20230711174853249](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20230711174853249.png)

#### 瓦片碰撞复合体

首先是小碰撞体

1. 为Tilemap添加Tilemap Collider 2D脚本，此时所有瓦片都会有绿色碰撞体方块。
2. 在Tiles文件夹下选择我们不想要添加碰撞体的tile（可以一次性多选），将inspector中Collider Type选为None

构建碰撞复合体。太多零碎的小collider会造成计算量过大，所以要使用碰撞复合体。

1. 为Tilemap添加Composite Collider 2D组件（自动附带Rigidbody 2D）
2. 在**Tilemap Collider 2D（和上面那个不一样）**中启用Used By Composite
3. 在Rigidbody 2D中 rigidbody type 选为static（禁止刚体移动）
4. 现在部分瓦片就能构成一个大矩形碰撞体了。

#### 触发器

is Trigger让带有碰撞框的物体能够触发回调函数，但是不具有问物理效果（阻塞运动 / 碰撞等）

回调函数需要放在一个脚本组件里，使用特定名称的hook。

```c#
private void OnTriggerEnter2D(Collider2D other)
{
    // 触发enter时，调用debug.log
    Debug.Log("Object that entered the trigger : " + other);
}
```

![image-20230712152710193](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20230712152710193.png)

生命恢复道具的函数如下。

```c#
private void OnTriggerEnter2D(Collider2D other)
{
    RubyController controller = other.GetComponent<RubyController>();
    // 判断是否为NULL考虑到可能其他移动单位（如敌人）也能与道具产生碰撞
    if (!controller)
    {
        controller.ChangeHealth(1);
        Destroy(gameObject);
    }
}
```

#### 保护私有变量

在人物控制脚本中，我们设置了一个private currentHealth属性表示当前血量，而在回复血量道具的脚本中，需要对这个变量进行修改，但是修改之前需要先将currentHealth与maxHealth进行比较。

由于currentHealth是私有变量，所以没法访问。此时

1. 将currentHealth变量设置为readonly：显然不行，因为之后还要修改
2. 将currentHealth设置为public：可能会在其他地方修改到该值，并且可能违背规则
3. 添加一个getter：也许比较好，可在getter内部添加一些规则，例如访问权限等。

#### repeat掉血区域

1. 首先当然要给最原始的区域添加掉血脚本,添加碰撞体，以及设置is Trigger

2. 为了能够扩大面积并且同时让精灵图不失真，需要

3. 设置Draw Mode和Tile Mode。前者让它能像瓦片一样平铺，Adaptive让图像保持完整（而不是填充物是被裁剪的 Continuos）

   ![image-20230713091826681](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20230713091826681.png)

4. 此时会报警告，精灵图不是Full Rect的，于是设置Project窗口中对应的员精灵Mesh Type改为Full Rect

5. 最后修改Box Collider，让碰撞大小自动改变

   ![image-20230713092156036](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20230713092156036.png)

#### 使用Animator为精灵添加动画

为对象增加Animator组件，通过Animator的Controller设置在何种情况下播放何种动画。

Animator Controller是控制动画的。

动画从Animation Clip中来。你需要手动创建AC，过程如下。

选中要创建的对象，Ctrl +6 呼出Animation Window，在此页面上可以创作动画。

1. 拖入制作动画的精灵图，播放预览效果
2. 修改Samples的值（如果没有，可在时间轴最右侧三个点找到）。Sample取样数，决定了1秒钟使用几张图片。如果动画只有4张，那么Sample = 4.
3. 左右动画可以通过添加Flip X 来实现

#### Controller组织动画

在Controller中右键Create New State -> Create New Blend Tree

双击Blend Tree进入设置页面

![image-20230713154421338](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20230713154421338.png)

 最左侧设置与动画相关的参数，右上角设置Blend Type，2d动画选择2D Directional Coordinate

右下角添加动画，并设置对应的参数PosX，PosY，两个变量的值（这里是aa和Blend与之对应，更接近哪个就播放哪个动画）

#### 通过脚本操控Animator Controller

```c#
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEditor.Animations;
using UnityEngine;

public class EnemyController : MonoBehaviour
{
	// 设置animator属性
    Animator animator;
   
    void Start()
    {
        // 获取挂载对象的Animator脚本
        animator = GetComponent<Animator>();
    }

    // Blend Tree的两个参数是MoveX和MoveY
    void CertainFunc(){
		 animator.SetFloat("MoveX", positiveDirection);
         animator.SetFloat("MoveY", 0);
    }
}
```

#### 避免碰撞

可以将对象设置在不同的层，然后再Edit -> Project Settings -> Physics / Physics 2D中查看哪些层可以碰撞

#### Has Exit Time

勾选上，代表动画必须播放完，不允许中途切换状态到另外一个动画。

去掉，则可以播放一般就被打断，切换到新的动画。（CS换弹动作被换枪动作替换）

#### 摄像机之间切换

在对话、过长动画中，往往需要在多个摄像机之间进行切换，我们在这里使用Cinemachine包。

在Hierarchy右键->Cinemachine->2d Camera创建一个虚拟相机。如果创建了多个相机，Main Camera可以在这些照相机之间进行切换。

此时默认的相机范围被改大了，进入Inspector->lens ->Ortho Size设置摄像范围。Ortho Size决定了高度的一半能够包含多少世界单位。【为什么要设置高度而不设置宽度？实际上，这是因为宽度会根据用户为游戏窗口设置的分辨率而变化。但是垂直高度始终相同】

设置一个Empty Object当作照相机边界，为这个Obj添加Polygon Collider2d，（ctrl点击可以删除顶点），将其设为。为vacm添加Cinemachine Confiner2D脚本，并且设置边界对象为之前的空对象。注意要为这个边界去除碰撞（单独设为一层，与其他层均不碰撞）。

#### 设置粒子系统

#### 设置UI

Hierarchy中Create -> UI -> Canvas ，附带会创建一个Event System，用于和UI进行交互。

UI在Scene和Game中的视图不一样，最好通过Game视图查看当前UI的效果。

为UI create一个UI->Image，修改该Image的源图片以及改变其位置（继续可在Game中观察）。

#### UI锚点设置

图片锚点与UI锚点距离在屏幕分辨率变化的过程中会保持不变，为了保证图片在分辨率变化时位置保持相对不变。需要设置锚点位置。

![image-20230717135312696](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20230717135312696.png)

点击Rect Transform的左上角团进行选择。

![image-20230717135430776](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20230717135430776.png)

UI Image要在左上角，所以要把锚点设置在左上角，这样如果屏幕从左边缩小，image也能向右移动（但如果从右边缩小就不行了）。

选择左上角九个锚点是绝对距离缩放。

如果使用右下角，那么子Image就是相对于父Image的等比例缩放（四个角的距离决定了子Image的放缩比例）。

改变四个锚点位置，以实现子Image的正常比例放缩。

![image-20230717142055828](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20230717142055828.png)

#### 使用遮罩表示血量条

传统方式是拉伸血量条图片，满时scale=1，空时scale=0.这回造成血量条可能会比较扁。

遮罩相当与取交集，取遮罩与子图片的公共部分显示。创建方式如下

1. 创建UI->Image ，取名为Mask，将其放在合适的位置，并且锚点放在四个角上保证能够随父亲等比例缩放。
   ![image-20230717151100446](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20230717151100446.png)
2. 移动轴心到最左侧（见上图），因为等等代码压缩是需要向左压缩。【实际上应该根据事实而定，轴心在中间的话缩小20% = 左右各缩小10%】
3. 为遮罩创建子Image，按住alt选中设置anchor的图标，选择右下角让孩子填充满Mask
   ![image-20230717151655586](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20230717151655586.png)
4. Mask添加脚本Mask，取消Show Mask Graphic，让遮罩层隐藏
5. 大功告成，改变Mask大小，就能决定血条的显示。

【Anchor与Pivot】

Anchor表示缩放依据点。放在四个角上就是完全随父亲缩放。放在最左侧，根据Pivot到Anchor的距离缩放。

图形用Pivot代指自己，改变Transform改变的是Anchor。

#### 更新血条的代码

因为血条只有一个，所以采用单例设计模式。

instance在初始化时指向自己。外界只能get，不能set。

mask是遮罩层对象，originalSize记录了原本的大小。

向外界提供一个SetValue函数用于控制mask的宽度。

血条脚本绑定到UI上，Mask对象成为脚本的mask。

```c#
public class UIHealthBar : MonoBehaviour
{
   
    public static UIHealthBar instance { get; private set; }
    public Image mask;
    float originalSize;
    // Start is called before the first frame update
    private void Awake()
    {
        instance = this;
    }
    void Start()
    {
        originalSize = mask.rectTransform.rect.width;
    }

    public void SetValue(float value)
    {
        mask.rectTransform.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, originalSize * value);
    }
}
```

在血量改变出使用instance.SetValue对血量进行修改。

```c#  
  UIHealthBar.instance.SetValue(currentHealth/ (float)maxHealth);
```

#### NPC对话

将三张图片一起拖入游戏能够直接创建一个三帧的动画。

1. 为NPC创建一个Box Collider 2D，方便之后判定与NPC邻近，将NPC作为预制件。NPC放在NPC layer

2. 为游戏角色增加一个对话键，通过Raycast的方式，判定邻近程度。
   ```c#
   if (Input.GetKeyDown(KeyCode.X))
   {
   // Raycast(起始点、方向、距离、层)
       RaycastHit2D hit = Physics2D.Raycast(rigidbody2d.position + Vector2.up * 0.2f, lookDirection, 1.5f, LayerMask.GetMask("NPC"));
       if (hit.collider != null)
       {
           Debug.Log("Raycast has hit the object " + hit.collider.gameObject);
       }
   }
   ```

3. 制作对话UI。在Hierarchy中为NPC创建一个UI -> Canvas对象，修改Rendor Mode为World Space。
   【Render Mode介绍】
   Overlay(画布投射到整个屏幕空间，UI元素必然置于屏幕最上层，永远在其他元素前面，静态的人物血条蓝量UI，如果有多个Overlay UI，需要调整Sort Order以控制绘制顺序)
   Camera(画布放在摄影机前方，要为Canvas链接一个Camera，Canvas会被物体遮挡，但是与Camera相对位置永远不变)
   World Space(画布被视为与长经常其他普通游戏对象性质相似的类似于面片的游戏物体，比如跟随人物移动的血条，NPC头上的对话框)

4. 画布此时会比较大，将其修改为合适的尺寸。例如3*2 (或者300\*200 + scale = 0.01)。

   同时将画布移至合适的位置

5. 为Canvas添加对话背景。Hierarchy中Canvas右键创建UI -> Image，选择图片加入，在Rect Transform中按住Alt选择右下角填充画布。调大Canvas的Sort Layer保证其最先绘制。

6. 为Canvas添加文本。选中Image对象，UI -> Text ->Test - MeshPro
   ![img](https://connect-cdn-public-prd.unitychina.cn/h1/20190821/learn/images/acd6ca0b-a4bc-4aed-bc62-9c2724f11187_pasted_image_0__1_.png)
   import TMP Essentials。
   调整好文本框边界，修改文字至想要的内容。

7. 控制对话的显隐。

   ![image-20230718114006471](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20230718114006471.png)
   修改这个小框，使其暂时消失。

   NPC脚本里添加一个public GameObject dialogBox属性（当然要把Canvas拖进去），初始设定消失。定时器部分略过。
   ```c#
   void Start()
   {
       dialogBox.SetActive(false);
   }
   ```

   需要编写一个让其显示的函数。

   ```c#
   public void DisplayDialog()
   {
       dialogBox.SetActive(true);
   }
   ```

   在玩家功能中，就可以在按下x进行Raycast后，调用此函数。

   ```c#
   if (!hit.collider)return;
   
   NonPlayerCharacter character = hit.collider.GetComponent<NonPlayerCharacter>();
   if (character != null)
   {
       character.DisplayDialog();
   }  
   ```

   内部需要一个定时器让Dialog定时消失

#### 音频设置

Audio Clip : 语音资源

Audio Listener：播放声音的位置，有利于“空间化”语音。默认放在Camera的位置。来自左侧的声音会在左声道播放，在右侧的声音会在右侧播放。

Audio Source：在其挂载的GameObject上播放Audio Clip。他相对于Audio Listener的位置会影响最终播放出来的声音（空间化）。当然即使不需要空间化的声音（例如背景音乐）也需要使用Aduio Source

![image-20230721134634130](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20230721134634130.png)

Spatial Blend：是否空间化，2D时无空间化（适用于背景音乐）

3D Sound Settings 中可以设置听见声音的Min / Max范围，

![image-20230721155635145](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20230721155635145.png)

声音范围其实是一个球。

![image-20230721155713411](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20230721155713411.png)

由于Audio Listener绑定在相机上，而相机与游戏平面有Z距离，因此attenuation 并不明显

#### 一次性声音

拾取物品，掉血都是一次性的声音，需要使用Audio Source的 PlayOneShot(AudioClip)函数进行播放

e.g. 拾取回血道具。道具拾取后会销毁，因此AudioSource不能放在道具上，可以放在主角上。道具上绑定一个AudioClip属性，主角上绑定一个Audio Source属性，碰撞后，道具主动调用主角的AudioSource播放自身的Clip。

## 导入3D模型

Skinned Mesh Renderer：蒙皮网格渲染器看。模型有三角形网格（mesh of triangles）组成，renderer渲染这些网格。相比于Mesh Render可以渲染动画。Skin绑在骨骼上，骨骼transform导致Skin Transform，从而播放动画。

骨骼：就是在John Lemon另一个Root元素，下的各个子元素。骨骼（一个object）可以进行旋转、平移、缩放等，带动Skin旋转、平移、缩放。

![image-20230722154310935](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20230722154310935.png)

Animator-Root Motion：未开启root motion时，unity动画会记录每帧游戏对象的绝对位置和绝对转角。动画下一个周期开始时，物体的位置和转角又变成了最初的数值。启用了root motion后，unity会计算在上一帧的相对位移和相对转角，再根据相对位移和相对转角来移动对象（始终利用相对位移、旋转改变物体）

#### 移动速度的Normalize()

通常是这样设置移动的，为什么要进行正规化？

```c#
void Update()
{
    float horizontal = Input.GetAxis("Horizontal");
    float vertiacal= Input.GetAxis("Vertiacal");
    m_Movemoent.Set(horizontal, 0f, vertiacal);
    m_Movemoent.Normalize();
}
```

为了让斜向移动的速度和正向移动的速度一样。（否则会跟起源引擎一样）

#### 转向

```c#
Vector3 desiredForward = Vector3.RotateTowards (transform.forward, m_Movement, turnSpeed * Time.deltaTime, 0f);
Quaternion m_Rotation = Quaternion.LookRotation(desiredForward);
// 从transform.forward转向m_movement
// 再存储在四元数中
```

transform.forward 区别于 vector3.forward，前者是世界坐标系里自身的朝向，后者是绝对的(0,0,1)

后两个是最大角速度，和矢量幅度变化？

#### 动画自身位移和脚本附加位移

脚本控制往往是w,s前后移动，启用了apply root motion后，动画自身的位移也会附加上来，导致向前移动地更多，向后反而可能正向移动。

我们使用脚本的方向（horizontal和vertical的值）并且使用脚本的移动速度。

```c#
void Update(){
    m_Rigidbody.movePosition(m_Rigidbody.position+ m_Movement* 				m_Animator.deltaPosition.magnitude)
}
```

如果像上面一样在Update函数中更改position，会造成既使用了大小速度和Animator一样的脚本移动（m_Movement*m_Animator.deltaPosition.magnitude）又会附加上本身Animator的移动。所以按W时会造成两倍的动画移动速度以及按S会停在原地。

```c#
private void OnAnimatorMove()
{
	m_Rigidbody.Move(m_Rigidbody.position + m_Movement * m_Animator.deltaPosition.magnitude, m_Rotation);
}
```

使用OnAnimatorMove hook，解决计算两遍的问题，此时root motion也被改变，如果你不附带任何m_Animator.deltaPosition的东西，就不会有播放动画的效果。

![image-20230723181827522](C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20230723181827522.png)

值得注意的是，如果OnAnimatorMove()调用时间过早会造成m_Movement尚未获取，于是Console会报一个警告。

#### Cinemachine

【使用前请导入Cinematic Studio包。右键Hierarchy创建Virtual Camera】

Unity使用Cinemachine控制多virtual摄像机以及virtual摄像机的移动。

Virtual Camera 有 Cinemachine Brain 脚本控制，由该脚本决定哪个是当前的Camera。



#### Post Processing

【使用前请导入Post Processing Package】

为摄像机加入一些后期处理效果，例如从昏暗的地方走入光明的地方，为摄像机增添一个光晕效果；或者为恐怖游戏增添一个暗蓝光环。

The groups of post processes are Assets called **Post-processing Profiles**. 

The areas of the game world which have profiles assigned to them are Components called **Post Process Volumes**.



#### Nav Mesh

创建游戏场景导航网格，可以指定NPC的移动。

```c#
public NavMeshAgent navMeshAgent;
public Transform[] waypoints;
int m_CurrentWaypointIndex;
// Start is called before the first frame update
void Start()
{
    navMeshAgent.SetDestination(waypoints[0].position);
}

// Update is called once per frame
void Update()
{
    // 快到了就切换下一个目标点
    if (navMeshAgent.remainingDistance < navMeshAgent.stoppingDistance && waypoints.Length!= 0)
    {
        m_CurrentWaypointIndex = (m_CurrentWaypointIndex + 1) % waypoints.Length;
        Debug.Log($"current waypoint:{waypoints[m_CurrentWaypointIndex]}");
        navMeshAgent.SetDestination(waypoints[m_CurrentWaypointIndex].position);
    }

}
```



## 使用Convai 的Unity Plugin

1. 去官网找到Convai 的Unity Plugin，会跳转到AssetStore，添加到我的资源。
2. 创建一个Unity 3D项目。菜单栏中依次选择Window->Package Manager -> 改选资源为My Assets
3. 找到刚才下载的Convai资源，Download并Import。
4. 注册一个Convai账号，再进入自己的Profile页面，复制自己的API key。
5. 在Unity项目的菜单栏中，找到Convai这个选项，点击Convai Setup，输入自己的API key，等待其在Resource里创建一个ConvaiAPIKEY.asset
6. 然后就可以运行了，按住L-Ctrl与AI对话。

## 无法直接修改transofrm.position

这是因为position定义的get函数实际上返回了一个值，因此我们如果使用transform.position.x = 1.0f，实际上并没有拿到x的地址，从而也就无法修改。

```c#
public Vector3 position
    {
        get
        {
            get_position_Injected(out var ret);
            return ret;
        }
        set
        {
            set_position_Injected(ref value);
        }
    }
```

