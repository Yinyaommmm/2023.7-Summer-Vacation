## 堆

#### 建堆

首先拿到乱序数组，总开始有孩子的位置(n-2)/2开始向上遍历，直至遍历到0。

以小顶堆为例，遍历就是下沉，小的数字浮上来。
就是与左孩子(2i+1) 右孩子(2i+2)较小的进行交换，没有则break;
交换后继续与新的孩子对比，直至没有孩子或break；

复杂度分析：初始层为0，最高层h，第i层元素有2^i个。

遍历是从h-1层开始，此时最多比1次，到h-2层时，最多比2次。
$$
\Sigma_{i=h-1}^{i=0} 2^i*(h-i)\\
\\令h-i = t\\
=\Sigma_{t=1}^{t=h}\ 2^{h-t} *t
\\由于2^h \leq n
\\ =\Sigma_{t=1}^{t=h}\ n\frac{t}{2^t}\\
简单的相消计算得 = O(n)
$$

#### 插入

新元素放在末尾，向上做一次冒泡。O(log n)

#### 获取并删除

交换a[0],a[size-1]，从0开始向下做一次make_heap，return a[size-1]。

O(log n)

## 计数排序

在出现元素范围已知的情况下，比较适用。

统计元素i出现的次数。

最后将hash表内的元素一次放入新数组。

## 桶排序

有m个桶，首先将元素hash到各个桶里，各桶内部排序。最后数据合并。

计数排序是m = n时的桶排序。

时间复杂度: O(n)遍历进行hash，然后每个桶进行排序，假设分布比较均匀，O（n/m log(n/m)）。

总时间 = O(n) + O (n/m log(n/m)) * m
			= O(n) + O(mlogn - mlogm)

当m = kn时(k < 1)，能够做到线性时间内排序。

需要数据比较均匀，或者让桶设计比较合理。

比如说对于正态分布的数据，期望附近的桶要多些。

## 比较排序的时间

考虑决策树

![image-20230906235734006](C:\Users\卫清渠\AppData\Roaming\Typora\typora-user-images\image-20230906235734006.png)

不断地比较元素，走对应路径，走打到底，就确定了顺序。

因为叶子节点恰好是n!个，而有关系叶子节点数 >= n /2；

所以总结点也就O（n!）个，最终，层高只有O(nlogn)。

#### 或者说从信息剔除的角度看

我们要知道的是下标1，2，3，... ，n对应的数字的排列。（假设数字都不同）

拿出1，2比较，无论是大于还是小于，一定能剔除n!/2种。

其实每次比较都能新剔掉一半，只要剩下1种，我们的排序就做完了。

那也就是 n! / 2^k = 1

k = O(nlogn)